{"ast":null,"code":"import { InjectionToken, Injectable, Inject, Optional, PLATFORM_ID, NgZone, ɵɵdefineInjectable, ɵɵinject, NgModule } from '@angular/core';\nimport { Subject, of, Observable, from, merge } from 'rxjs';\nimport { observeOn, switchMap, map, shareReplay, first, switchMapTo, subscribeOn, filter } from 'rxjs/operators';\nimport { ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory, ɵfirebaseAppFactory, ɵfetchInstance, ɵlazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵapplyMixins } from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: base.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst proxyPolyfillCompat = {\n  app: null,\n  applyActionCode: null,\n  checkActionCode: null,\n  confirmPasswordReset: null,\n  createUserWithEmailAndPassword: null,\n  currentUser: null,\n  fetchSignInMethodsForEmail: null,\n  isSignInWithEmailLink: null,\n  getRedirectResult: null,\n  languageCode: null,\n  settings: null,\n  onAuthStateChanged: null,\n  onIdTokenChanged: null,\n  sendSignInLinkToEmail: null,\n  sendPasswordResetEmail: null,\n  setPersistence: null,\n  signInAndRetrieveDataWithCredential: null,\n  signInAnonymously: null,\n  signInWithCredential: null,\n  signInWithCustomToken: null,\n  signInWithEmailAndPassword: null,\n  signInWithPhoneNumber: null,\n  signInWithEmailLink: null,\n  signInWithPopup: null,\n  signInWithRedirect: null,\n  signOut: null,\n  tenantId: null,\n  updateCurrentUser: null,\n  useDeviceLanguage: null,\n  useEmulator: null,\n  verifyPasswordResetCode: null\n};\n\n/**\n * @fileoverview added by tsickle\n * Generated from: auth.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// WARNING: interface has both a type and a value, skipping emit\n/** @type {?} */\nconst USE_EMULATOR = /*#__PURE__*/new InjectionToken('angularfire2.auth.use-emulator');\n/** @type {?} */\nconst SETTINGS = /*#__PURE__*/new InjectionToken('angularfire2.auth.settings');\n/** @type {?} */\nconst TENANT_ID = /*#__PURE__*/new InjectionToken('angularfire2.auth.tenant-id');\n/** @type {?} */\nconst LANGUAGE_CODE = /*#__PURE__*/new InjectionToken('angularfire2.auth.langugage-code');\n/** @type {?} */\nconst USE_DEVICE_LANGUAGE = /*#__PURE__*/new InjectionToken('angularfire2.auth.use-device-language');\n/** @type {?} */\nconst PERSISTENCE = /*#__PURE__*/new InjectionToken('angularfire.auth.persistence');\nlet AngularFireAuth = /*#__PURE__*/(() => {\n  class AngularFireAuth {\n    /**\n     * @param {?} options\n     * @param {?} nameOrConfig\n     * @param {?} platformId\n     * @param {?} zone\n     * @param {?} _useEmulator\n     * @param {?} _settings\n     * @param {?} tenantId\n     * @param {?} languageCode\n     * @param {?} useDeviceLanguage\n     * @param {?} persistence\n     */\n    constructor(options, nameOrConfig,\n    // tslint:disable-next-line:ban-types\n    platformId, zone, _useEmulator,\n    // can't use the tuple here\n    _settings,\n    // can't use firebase.auth.AuthSettings here\n    tenantId, languageCode, useDeviceLanguage, persistence) {\n      /** @type {?} */\n      const schedulers = new ɵAngularFireSchedulers(zone);\n      /** @type {?} */\n      const keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(schedulers);\n      /** @type {?} */\n      const logins = new Subject();\n      /** @type {?} */\n      const auth = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(\n      /**\n      * @return {?}\n      */\n      () => zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => import('firebase/auth'))), map(\n      /**\n      * @return {?}\n      */\n      () => ɵfirebaseAppFactory(options, zone, nameOrConfig)), map(\n      /**\n      * @param {?} app\n      * @return {?}\n      */\n      app => zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => {\n        /** @type {?} */\n        const useEmulator = _useEmulator;\n        /** @type {?} */\n        const settings = _settings;\n        return ɵfetchInstance(`${app.name}.auth`, 'AngularFireAuth', app,\n        /**\n        * @return {?}\n        */\n        () => {\n          /** @type {?} */\n          const auth = zone.runOutsideAngular(\n          /**\n          * @return {?}\n          */\n          () => app.auth());\n          if (useEmulator) {\n            // Firebase Auth doesn't conform to the useEmulator convention, let's smooth that over\n            auth.useEmulator(`http://${useEmulator.join(':')}`);\n          }\n          if (tenantId) {\n            auth.tenantId = tenantId;\n          }\n          auth.languageCode = languageCode;\n          if (useDeviceLanguage) {\n            auth.useDeviceLanguage();\n          }\n          if (settings) {\n            auth.settings = settings;\n          }\n          if (persistence) {\n            auth.setPersistence(persistence);\n          }\n          return auth;\n        }, [useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence]);\n      })), shareReplay({\n        bufferSize: 1,\n        refCount: false\n      }));\n      if (isPlatformServer(platformId)) {\n        this.authState = this.user = this.idToken = this.idTokenResult = this.credential = of(null);\n      } else {\n        // HACK, as we're exporting auth.Auth, rather than auth, developers importing firebase.auth\n        //       (e.g, `import { auth } from 'firebase/app'`) are getting an undefined auth object unexpectedly\n        //       as we're completely lazy. Let's eagerly load the Auth SDK here.\n        //       There could potentially be race conditions still... but this greatly decreases the odds while\n        //       we reevaluate the API.\n        /** @type {?} */\n        const _ = auth.pipe(first()).subscribe();\n        /** @type {?} */\n        const redirectResult = auth.pipe(switchMap(\n        /**\n        * @param {?} auth\n        * @return {?}\n        */\n        auth => auth.getRedirectResult().then(\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n        it => it,\n        /**\n        * @return {?}\n        */\n        () => null)), keepUnstableUntilFirst, shareReplay({\n          bufferSize: 1,\n          refCount: false\n        }));\n        /** @type {?} */\n        const fromCallback =\n        /**\n        * @template T\n        * @param {?} cb\n        * @return {?}\n        */\n        cb => new Observable(\n        /**\n        * @param {?} subscriber\n        * @return {?}\n        */\n        subscriber => ({\n          unsubscribe: zone.runOutsideAngular(\n          /**\n          * @return {?}\n          */\n          () => cb(subscriber))\n        }));\n        /** @type {?} */\n        const authStateChanged = auth.pipe(switchMap(\n        /**\n        * @param {?} auth\n        * @return {?}\n        */\n        auth => fromCallback(auth.onAuthStateChanged.bind(auth))));\n        /** @type {?} */\n        const idTokenChanged = auth.pipe(switchMap(\n        /**\n        * @param {?} auth\n        * @return {?}\n        */\n        auth => fromCallback(auth.onIdTokenChanged.bind(auth))));\n        this.authState = redirectResult.pipe(switchMapTo(authStateChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n        this.user = redirectResult.pipe(switchMapTo(idTokenChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n        this.idToken = this.user.pipe(switchMap(\n        /**\n        * @param {?} user\n        * @return {?}\n        */\n        user => user ? from(user.getIdToken()) : of(null)));\n        this.idTokenResult = this.user.pipe(switchMap(\n        /**\n        * @param {?} user\n        * @return {?}\n        */\n        user => user ? from(user.getIdTokenResult()) : of(null)));\n        this.credential = merge(redirectResult, logins,\n        // pipe in null authState to make credential zipable, just a weird devexp if\n        // authState and user go null to still have a credential\n        this.authState.pipe(filter(\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n        it => !it))).pipe(\n        // handle the { user: { } } when a user is already logged in, rather have null\n        // TODO handle the type corcersion better\n        map(\n        /**\n        * @param {?} credential\n        * @return {?}\n        */\n        credential => (credential === null || credential === void 0 ? void 0 : credential.user) ? /** @type {?} */credential : null), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      }\n      return ɵlazySDKProxy(this, auth, zone, {\n        spy: {\n          apply:\n          /**\n          * @param {?} name\n          * @param {?} _\n          * @param {?} val\n          * @return {?}\n          */\n          (name, _, val) => {\n            // If they call a signIn or createUser function listen into the promise\n            // this will give us the user credential, push onto the logins Subject\n            // to be consumed in .credential\n            if (name.startsWith('signIn') || name.startsWith('createUser')) {\n              // TODO fix the types, the trouble is UserCredential has everything optional\n              val.then(\n              /**\n              * @param {?} user\n              * @return {?}\n              */\n              user => logins.next( /** @type {?} */user));\n            }\n          }\n        }\n      });\n    }\n  }\n  /** @nocollapse */AngularFireAuth.ɵprov = ɵɵdefineInjectable({\n    factory: function AngularFireAuth_Factory() {\n      return new AngularFireAuth(ɵɵinject(FIREBASE_OPTIONS), ɵɵinject(FIREBASE_APP_NAME, 8), ɵɵinject(PLATFORM_ID), ɵɵinject(NgZone), ɵɵinject(USE_EMULATOR, 8), ɵɵinject(SETTINGS, 8), ɵɵinject(TENANT_ID, 8), ɵɵinject(LANGUAGE_CODE, 8), ɵɵinject(USE_DEVICE_LANGUAGE, 8), ɵɵinject(PERSISTENCE, 8));\n    },\n    token: AngularFireAuth,\n    providedIn: \"any\"\n  });\n  return AngularFireAuth;\n})();\n/** @nocollapse */\nif (false) {\n  /**\n   * Observable of authentication state; as of Firebase 4.0 this is only triggered via sign-in/out\n   * @type {?}\n   */\n  AngularFireAuth.prototype.authState;\n  /**\n   * Observable of the currently signed-in user's JWT token used to identify the user to a Firebase service (or null).\n   * @type {?}\n   */\n  AngularFireAuth.prototype.idToken;\n  /**\n   * Observable of the currently signed-in user (or null).\n   * @type {?}\n   */\n  AngularFireAuth.prototype.user;\n  /**\n   * Observable of the currently signed-in user's IdTokenResult object which contains the ID token JWT string and other\n   * helper properties for getting different data associated with the token as well as all the decoded payload claims\n   * (or null).\n   * @type {?}\n   */\n  AngularFireAuth.prototype.idTokenResult;\n  /**\n   * Observable of the currently signed-in user's credential, or null\n   * @type {?}\n   */\n  AngularFireAuth.prototype.credential;\n}\n/*#__PURE__*/ɵapplyMixins(AngularFireAuth, [proxyPolyfillCompat]);\n\n/**\n * @fileoverview added by tsickle\n * Generated from: auth.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass AngularFireAuthModule {}\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-fire-auth.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nexport { AngularFireAuth, AngularFireAuthModule, LANGUAGE_CODE, PERSISTENCE, SETTINGS, TENANT_ID, USE_DEVICE_LANGUAGE, USE_EMULATOR };\n//# sourceMappingURL=angular-fire-auth.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}